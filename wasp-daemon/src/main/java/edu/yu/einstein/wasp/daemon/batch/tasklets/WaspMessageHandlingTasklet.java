package edu.yu.einstein.wasp.daemon.batch.tasklets;

import java.util.Set;

import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.StepExecutionListener;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.scope.context.StepContext;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.integration.Message;
import org.springframework.integration.MessageChannel;
import org.springframework.integration.MessageHeaders;
import org.springframework.integration.channel.PublishSubscribeChannel;
import org.springframework.integration.core.MessagingTemplate;
import org.springframework.integration.support.MessageBuilder;

import edu.yu.einstein.wasp.integration.endpoints.BatchJobHibernationManager;
import edu.yu.einstein.wasp.integration.messages.WaspStatus;
import edu.yu.einstein.wasp.integration.messages.templates.MessageAwokenHibernationMessageTemplate;
import edu.yu.einstein.wasp.integration.messages.templates.MessageTemplate;

public abstract class WaspMessageHandlingTasklet extends WaspTasklet implements StepExecutionListener{
	
	protected Set<Message<?>> messageQueue;
	
	protected boolean wasHibernationSuccessfullyRequested = false;
	
	@Autowired
	@Qualifier("wasp.channel.reply")
	PublishSubscribeChannel replyChannel;
	
	@Autowired
	@Qualifier("wasp.channel.priority.default")
	MessageChannel sendChannel;
	
	protected void sendSuccessReplyToAllMessagesInQueue(){
		MessagingTemplate messagingTemplate = new MessagingTemplate();
		logger.debug("Going to send " + messageQueue.size()  + " reply message(s)...");
		for (Message<?> message: messageQueue){
			try{
				logger.debug("sending reply to message: " + message.toString());
				// this is a little complex. What we do here is attach the temporary point-to-point reply channel generated by the gateway
				// and attached to the source message to the reply message and send it on the 'wasp.channel.reply' channel. 
				// The Gateway will create a bridge from it to the temporary, anonymous reply channel that is stored in the header.
				// Of course if there is no reply channel specified then no reply will be sent.
				if ( message.getHeaders().containsKey(MessageHeaders.REPLY_CHANNEL)){
					Message<WaspStatus> replyMessage = MessageBuilder
							.withPayload(WaspStatus.COMPLETED)
							.setReplyChannel((MessageChannel) message.getHeaders().get(MessageHeaders.REPLY_CHANNEL))
							.build();
					logger.debug("sending reply message: " + replyMessage.toString());
					messagingTemplate.send(replyChannel, replyMessage);
				} else
					logger.debug("No reply message sent because no reply channel was specified in the original message");
			} catch (Exception e){
				logger.warn("Failure to send reply message (reason: " + e.getLocalizedMessage() + ") to reply channel specified in source message : " +
						message.toString() + ". Original exception stack: ");
				e.printStackTrace();
			}
		}
	}
	
	protected void requestHibernation(ChunkContext context, Set<MessageTemplate> messages){
		StepContext stepContext = context.getStepContext();
		Long jobExecutionId = stepContext.getStepExecution().getJobExecutionId();
		logger.info("Going to hibernate job " + stepContext.getJobName() + 
				" (execution id=" + stepContext.getStepExecution().getJobExecutionId() + ") from step " + 
				stepContext.getStepName() + " (step id=" + stepContext.getStepExecution().getId() + ")");
		MessageAwokenHibernationMessageTemplate messageTemplate = new MessageAwokenHibernationMessageTemplate(stepContext.getStepExecution());
		messageTemplate.setAwakenJobExecutionOnMessages(messages);
		Message<Set<MessageTemplate>> message = null;
		try {
			message = messageTemplate.build();
			logger.debug("sending message: " + message);
			MessagingTemplate messagingTemplate = new MessagingTemplate();
			messagingTemplate.send(sendChannel, message);
			wasHibernationSuccessfullyRequested = true;
		} catch (Exception e) {
			logger.warn("Unable to hibernate batch JobExecution id= " + jobExecutionId + ". Failure to send reply message (reason: " + 
					e.getLocalizedMessage() + ") to reply channel specified in source message : " + message.toString() + ". Original exception stack: ");
			e.printStackTrace();
		}
	}
	
	protected boolean wasHibernating(ChunkContext context){
		ExecutionContext executionContext = context.getStepContext().getStepExecution().getJobExecution().getExecutionContext();
		if (!executionContext.containsKey(BatchJobHibernationManager.HIBERNATING_CODE))
			return false;
		boolean isHibernating = (boolean) executionContext.get(BatchJobHibernationManager.HIBERNATING_CODE);
		logger.debug("StepExecutionId=" + context.getStepContext().getStepExecution().getId() + " isHibernating=" + isHibernating);
		return isHibernating;	
	}
	
	protected void setWasHibernatingFlag(ChunkContext context, boolean value){
		ExecutionContext executionContext = context.getStepContext().getStepExecution().getJobExecution().getExecutionContext();
		executionContext.put(BatchJobHibernationManager.HIBERNATING_CODE, value);
	}
	
	@Override
	public void beforeStep(StepExecution stepExecution) {
		// Do Nothing here
	}
	
	@Override
	public ExitStatus afterStep(StepExecution stepExecution){
		sendSuccessReplyToAllMessagesInQueue();
		this.messageQueue.clear(); // clean up in case of restart
		logger.debug(name + "AfterStep() going to return ExitStatus of '" + stepExecution.getExitStatus().getExitCode().toString() + "'");
		return stepExecution.getExitStatus();
	}
}
