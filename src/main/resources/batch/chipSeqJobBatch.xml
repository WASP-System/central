<?xml version="1.0" encoding="UTF-8"?>
<beans
    xsi:schemaLocation=" http://www.springframework.org/schema/beans 
  http://www.springframework.org/schema/beans/spring-beans-3.1.xsd     
  http://www.springframework.org/schema/context  
  http://www.springframework.org/schema/context/spring-context-3.1.xsd 
  http://www.springframework.org/schema/mvc 
  http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd  
  http://www.springframework.org/schema/aop 
  http://www.springframework.org/schema/aop/spring-aop-3.1.xsd
  http://www.springframework.org/schema/tx
  http://www.springframework.org/schema/tx/spring-tx-3.1.xsd
  http://www.springframework.org/schema/integration
  http://www.springframework.org/schema/integration/spring-integration-2.0.xsd
  http://www.springframework.org/schema/integration/file
  http://www.springframework.org/schema/integration/file/spring-integration-file-2.0.xsd
  http://www.springframework.org/schema/batch 
  http://www.springframework.org/schema/batch/spring-batch-2.1.xsd
  "
    xmlns:mvc="http://www.springframework.org/schema/mvc" 
    xmlns:aop="http://www.springframework.org/schema/aop" 
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:p="http://www.springframework.org/schema/p" 
    xmlns:batch="http://www.springframework.org/schema/batch" 
    xmlns:tx="http://www.springframework.org/schema/tx" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:si="http://www.springframework.org/schema/integration" 
    xmlns:file="http://www.springframework.org/schema/integration/file" 
    xmlns="http://www.springframework.org/schema/beans"
    default-autowire="byName">

  <bean id="chipSeqStartJobPoller" parent="workflowPoller">
    <property name="workflowIName"  value="chipSeq"/>
    <property name="taskIName" value="Start Job"/>
  </bean> 
  <si:inbound-channel-adapter ref="chipSeqStartJobPoller" method="getStates" channel="chipSeqJobCreateRequestChannel">
    <si:poller>
      <si:interval-trigger interval="5000" />
    </si:poller>
  </si:inbound-channel-adapter>

  <!-- intermediary for output from jobCreateRequestChannel: -->
  <!-- calls StateJobLaunchingMessageHandler which calls batch:job 'Start Job' (see below) -->	
  <si:service-activator input-channel="chipSeqJobCreateRequestChannel" output-channel="logger">
    <bean class="edu.yu.einstein.wasp.batch.StateJobLaunchingMessageHandler" scope="prototype">
       <constructor-arg ref="jobRegistry" />
       <constructor-arg ref="jobLauncher" />
       <constructor-arg ref="jobRepository" />
       <constructor-arg ref="jobOperator" />
       <constructor-arg type="java.lang.String"><value>chipSeqStartJob</value></constructor-arg>
    </bean>
  </si:service-activator>


  <bean id="createBoneShakerApprovalStateStep" parent="parentStateStep">
    <property name="itemProcessor">
      <bean class="edu.yu.einstein.wasp.batch.CreateJobStateProcessor">
        <property name="targetTask" value="boneShakerApprovalTask" />
      </bean>
    </property>
  </bean>

  <bean id="waitForBoneShakerApprovalStateUpdated" parent="parentStateStep">
    <property name="itemProcessor">
      <bean class="edu.yu.einstein.wasp.batch.WaitForSiblingJobStateProcessor">
        <property name="task" value="boneShakerApprovalTask" />
        <property name="status" value="APPROVED" />
        <property name="siblingTargetStatus" value="FINAL" />
      </bean>
    </property>
  </bean>

  <batch:flow id="boneShakerApprovalFlow">
    <batch:step id="boneShakerApprovalStep0" parent="createBoneShakerApprovalStateStep" next="boneShakerApprovalStep1" />
    <batch:step id="boneShakerApprovalStep1" parent="waitForBoneShakerApprovalStateUpdated" />
  </batch:flow>

  <bean class="edu.yu.einstein.wasp.batch.DoCommandStateTasklet" id="sendInvoiceTasklet" scope="step">
    <property name="stateId">
      <value>#{jobParameters['state']}</value>
    </property>
    <property name="params">
      <list>
        <value>'/tmp/abc.pl'</value>
        <value>'goodbye'</value>
        <value>new String('hello world').toUpperCase()</value>
        <value>#m['state'].name</value>
        <value>#m['state'].statejob[0].job.name</value>
        <value>#m['state'].statejob[0].job.workflow.iName</value>
        <value>'#{jobParameters['state']}'</value>
        <value>'goodbye'</value>
      </list>
    </property>

    <!-- 5 second timeout for the command to complete -->
    <property name="timeout" value="5000" />
  </bean>


  <batch:job id="chipSeqStartJobTest">
    <batch:step id="sendInvoiceTaskStepTest">
      <batch:tasklet ref="sendInvoiceTasklet" />
    </batch:step>
  </batch:job>


  <batch:job id="chipSeqStartJob">
    <batch:step id="chipSeq.startJob0" parent="createSampleReceiveStateStep" next="chipSeq.approvals" />

    <batch:split id="chipSeq.approvals" next="sendInvoiceTaskStep" task-executor="asyncTaskExecutor">
      <batch:flow>
        <batch:flow id="chipSeq.quoteFlow" parent="quoteFlow" />
      </batch:flow>
      <batch:flow>
        <batch:flow id="chipSeq.piApprovalFlow" parent="piApprovalFlow" />
      </batch:flow>
      <batch:flow>
        <batch:flow id="chipSeq.daApprovalFlow" parent="daApprovalFlow" />
      </batch:flow>
      <batch:flow>
        <batch:flow id="chipSeq.boneShakerApprovalFlow" parent="boneShakerApprovalFlow" />
      </batch:flow>
    </batch:split> 

    <!-- send and invoice -->
    <batch:step id="sendInvoiceTaskStep" next="chipSeq.invoiceFlow" >
      <batch:tasklet ref="sendInvoiceTasklet" />
    </batch:step>
    <batch:flow id="chipSeq.invoiceFlow" parent="invoiceFlow" next="chipSeq.samplesReceivedFlow" />

    <!-- receive all the samples -->
    <batch:flow id="chipSeq.samplesReceivedFlow" parent="allSamplesReceivedFlow" next="chipSeq.samplesFinalFlow" />
    <batch:flow id="chipSeq.samplesFinalFlow" parent="allSamplesFinalFlow" next="chipSeq.finishFlow" />

    <batch:flow id="chipSeq.finishFlow" parent="finishJobFlow" />
  </batch:job>

</beans>
