<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:batch="http://www.springframework.org/schema/batch"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/batch http://www.springframework.org/schema/batch/spring-batch.xsd">

	<!-- for job, call with parameter 'runID' -->
	<batch:flow id="waspIlluminaHiSeq.mainFlow">
		<batch:step id="waspIlluminaHiSeq.mainFlow.notifyIlluminaStart" next="waspIlluminaHiSeq.mainFlow.listenForRunStart">
			<batch:tasklet>
						<batch:transaction-attributes propagation="NEVER"/>
				<bean class="edu.yu.einstein.wasp.daemon.batch.tasklets.NotifyStatusTasklet" scope="step">
					<constructor-arg name="outputMessageChannel" ref="wasp.channel.batch" />
					<constructor-arg name="messageTemplate">
						<bean class="edu.yu.einstein.wasp.integration.messages.templates.RunStatusMessageTemplate">
							<constructor-arg name="runId" value="#{jobParameters[waspJobParameters.RUN_ID]}" />
							<property name="status" value="STARTED" />
						</bean>
					</constructor-arg>
				</bean>
			</batch:tasklet>
		</batch:step>
		<batch:step id="waspIlluminaHiSeq.mainFlow.listenForRunStart" next="waspIlluminaHiSeq.mainFlow.listenForRunCompletion">
			<!-- look for evidence of a started illumina run. One of the first steps is to write the runParameters.xml file -->
			<batch:tasklet>
						<batch:transaction-attributes propagation="NEVER"/>
				<bean class="edu.yu.einstein.wasp.daemon.batch.tasklets.file.ExternalFileExistsTasklet" scope="step">
					<constructor-arg name="softwarePackage" ref="casava" />
					<constructor-arg name="directoryId" value="illumina.data.dir" />
					<constructor-arg name="filename" value="#{jobParameters[waspJobParameters.RUN_NAME]}/runParameters.xml" />
				</bean>
			</batch:tasklet>
		</batch:step>
		<batch:step id="waspIlluminaHiSeq.mainFlow.listenForRunCompletion" next="waspIlluminaHiSeq.mainFlow.updateRunCompleted">
			<!-- look for evidence of a completed illumina run. At the moment, we look for "RTAComplete.txt" (not present in MiSeq) -->
			<batch:tasklet>
						<batch:transaction-attributes propagation="NEVER"/>
				<bean class="edu.yu.einstein.wasp.daemon.batch.tasklets.file.ExternalFileExistsTasklet" scope="step">
					<constructor-arg name="softwarePackage" ref="casava" />
					<constructor-arg name="directoryId" value="illumina.data.dir" />
					<constructor-arg name="filename" value="#{jobParameters[waspJobParameters.RUN_NAME]}/RTAComplete.txt" />
				</bean>
			</batch:tasklet>
		</batch:step>
		<batch:step id="waspIlluminaHiSeq.mainFlow.updateRunCompleted" next="waspIlluminaHiSeq.mainFlow.dualIndexSplit">
			<!-- task to create a sample sheet. Should do some rudimentary checking on samples. -->
			<batch:tasklet>
						<batch:transaction-attributes propagation="NEVER"/>
				<bean class="edu.yu.einstein.wasp.plugin.illumina.batch.tasklet.UpdateRunCompletedTasklet" scope="step">
					<constructor-arg name="runId" value="#{jobParameters[waspJobParameters.RUN_ID]}" />
				</bean>
			</batch:tasklet>
		</batch:step>
		<batch:split id="waspIlluminaHiSeq.mainFlow.dualIndexSplit" next="waspIlluminaHiSeq.mainFlow.processSAV">
		<!--  processing of illumina runs proceeds in a split step since single index reads and dual index
				reads require separate runs of the CASAVA pipeline.  Under no circumstances should single
				index reads and dual index reads be run in the same flowcell lane.   -->
		<batch:flow>
		<batch:step id="waspIlluminaHiSeq.mainFlow.createSampleSheet" next="waspIlluminaHiSeq.mainFlow.startIlluminaPipeline">
			<!-- task to create a sample sheet. Should do some rudimentary checking on samples. -->
			<batch:tasklet>
						<batch:transaction-attributes propagation="NEVER"/>
				<bean class="edu.yu.einstein.wasp.plugin.illumina.batch.tasklet.SampleSheetTasklet" scope="step">
					<constructor-arg name="runId" value="#{jobParameters[waspJobParameters.RUN_ID]}" />
					<constructor-arg name="method" value="single" />
				</bean>
			</batch:tasklet>
		</batch:step>
		<batch:step id="waspIlluminaHiSeq.mainFlow.startIlluminaPipeline">
			<!-- initiate the illumina pipeline -->
			<batch:tasklet>
						<batch:transaction-attributes propagation="NEVER"/>
				<bean class="edu.yu.einstein.wasp.plugin.illumina.batch.tasklet.PipelineTasklet" scope="step">
					<constructor-arg name="runId" value="#{jobParameters[waspJobParameters.RUN_ID]}" />
					<constructor-arg name="method" value="single" />
				</bean>
			</batch:tasklet>
		</batch:step>
		</batch:flow>
		<batch:flow>
		<batch:step id="waspIlluminaHiSeq.mainFlow.createSampleSheetDual" next="waspIlluminaHiSeq.mainFlow.startIlluminaPipelineDual">
			<!-- task to create a sample sheet. Should do some rudimentary checking on samples. -->
			<batch:tasklet>
						<batch:transaction-attributes propagation="NEVER"/>
				<bean class="edu.yu.einstein.wasp.plugin.illumina.batch.tasklet.SampleSheetTasklet" scope="step">
					<constructor-arg name="runId" value="#{jobParameters[waspJobParameters.RUN_ID]}" />
					<constructor-arg name="method" value="dual" />
				</bean>
			</batch:tasklet>
		</batch:step>
		<batch:step id="waspIlluminaHiSeq.mainFlow.startIlluminaPipelineDual">
			<!-- initiate the illumina pipeline -->
			<batch:tasklet>
						<batch:transaction-attributes propagation="NEVER"/>
				<bean class="edu.yu.einstein.wasp.plugin.illumina.batch.tasklet.PipelineTasklet" scope="step">
					<constructor-arg name="runId" value="#{jobParameters[waspJobParameters.RUN_ID]}" />
					<constructor-arg name="method" value="dual" />
				</bean>
			</batch:tasklet>
		</batch:step>
		</batch:flow>
		</batch:split>
		<batch:step id="waspIlluminaHiSeq.mainFlow.processSAV" next="waspIlluminaHiSeq.mainFlow.stageResults">
			<!-- generate QC metrics pictures a la Illumina reports -->
			<batch:tasklet>
				<batch:transaction-attributes propagation="NEVER"/>
				<bean class="edu.yu.einstein.wasp.plugin.illumina.batch.tasklet.ProcessSAVTasklet" scope="step">
					<constructor-arg name="runId" value="#{jobParameters[waspJobParameters.RUN_ID]}" />
				</bean>
			</batch:tasklet>
		
		</batch:step>
		<batch:step id="waspIlluminaHiSeq.mainFlow.stageResults" next="waspIlluminaHiSeq.mainFlow.trim">
			<batch:tasklet>
						<batch:transaction-attributes propagation="NEVER"/>
				<bean class="edu.yu.einstein.wasp.plugin.illumina.batch.tasklet.StageResultsTasklet" scope="step">
					<constructor-arg name="runId" value="#{jobParameters[waspJobParameters.RUN_ID]}" />
				</bean>
			</batch:tasklet>
		</batch:step>
		<batch:step id="waspIlluminaHiSeq.mainFlow.trim" next="waspIlluminaHiSeq.mainFlow.demultiplex">
			<batch:tasklet>
				<bean class="edu.yu.einstein.wasp.plugin.illumina.batch.tasklet.TrimTasklet" scope="step">
					<constructor-arg name="runId" value="#{jobParameters[waspJobParameters.RUN_ID]}" />
				</bean>
			</batch:tasklet>
		</batch:step>
		<batch:step id="waspIlluminaHiSeq.mainFlow.demultiplex" next="waspIlluminaHiSeq.mainFlow.registerFiles">
			<!-- task to perform 5' demultiplexing, currently skipping -->
			<batch:tasklet ref="waspIlluminaHiSeq.mainFlow.skipTasklet" />
		</batch:step>
		<batch:step id="waspIlluminaHiSeq.mainFlow.registerFiles" next="waspIlluminaHiSeq.mainFlow.listenForQCCompletion">
			<batch:tasklet>
						<batch:transaction-attributes propagation="NEVER"/>
				<bean class="edu.yu.einstein.wasp.plugin.illumina.batch.tasklet.RegisterFilesTasklet" scope="step">
					<constructor-arg name="runId" value="#{jobParameters[waspJobParameters.RUN_ID]}" />
				</bean>
			</batch:tasklet>
		</batch:step>
		<batch:step id="waspIlluminaHiSeq.mainFlow.listenForQCCompletion" next="waspIlluminaHiSeq.mainFlow.notifyRunComplete">
			<batch:tasklet>
						<batch:transaction-attributes propagation="NEVER"/>
				<bean class="edu.yu.einstein.wasp.daemon.batch.tasklets.ListenForStatusTasklet" scope="step">
					<constructor-arg name="inputSubscribableChannel" ref="wasp.channel.notification.run" />
					<constructor-arg name="abortMonitoringChannel" ref="wasp.channel.notification.abort"/>
					<constructor-arg name="messageTemplate">
						<bean class="edu.yu.einstein.wasp.integration.messages.templates.RunStatusMessageTemplate">
							<constructor-arg name="runId" value="#{jobParameters[waspJobParameters.RUN_ID]}" />
							<property name="task" value="#{runTasks.QC}" />
							<property name="status" value="COMPLETED" />
						</bean>
					</constructor-arg>
				</bean>
			</batch:tasklet>
		</batch:step>
		<batch:step id="waspIlluminaHiSeq.mainFlow.notifyRunComplete">
			<batch:tasklet>
						<batch:transaction-attributes propagation="NEVER"/>
				<bean class="edu.yu.einstein.wasp.daemon.batch.tasklets.NotifyStatusTasklet" scope="step">
					<constructor-arg name="outputMessageChannel" ref="wasp.channel.batch" />
					<constructor-arg name="messageTemplate">
						<bean class="edu.yu.einstein.wasp.integration.messages.templates.RunStatusMessageTemplate">
							<constructor-arg name="runId" value="#{jobParameters[waspJobParameters.RUN_ID]}" />
							<property name="status" value="COMPLETED" />
						</bean>
					</constructor-arg>
				</bean>
			</batch:tasklet>
		</batch:step>
	</batch:flow>

	<bean id="waspIlluminaHiSeq.mainFlow.skipTasklet" class="edu.yu.einstein.wasp.daemon.batch.tasklets.SkipTasklet" scope="step" />

	<batch:flow id="waspIlluminaHiSeq.exitCondition">
		<!-- Will listen for indicators that the flow should terminate such as the wasp job flow has been aborted or -->
		<!-- if the wasp.default.sample.mainFlow flow completes (broadcasting an ACCEPTED status message) or is aborted -->
		<!-- e.g. via a message from the web layer -->
		<batch:step id="waspIlluminaHiSeq.step.listenForExitCondition">
			<batch:tasklet>
						<batch:transaction-attributes propagation="NEVER"/>
				<bean class="edu.yu.einstein.wasp.daemon.batch.tasklets.ListenForExitConditionTasklet" scope="step">
					<constructor-arg name="inputSubscribableChannels">
						<set>
							<ref bean="wasp.channel.notification.run" />
						</set>
					</constructor-arg>
					<constructor-arg name="abortMonitoringChannel" ref="wasp.channel.notification.abort" />
					<constructor-arg name="messageTemplates">
						<set>
							<!-- listen for COMPLETED message from the other flow as a signal to terminate cleanly -->
							<bean class="edu.yu.einstein.wasp.integration.messages.templates.RunStatusMessageTemplate">
								<constructor-arg name="runId" value="#{jobParameters[waspJobParameters.RUN_ID]}" />
								<property name="status" value="COMPLETED" />
							</bean>
						</set>
					</constructor-arg>
					<property name="name" value="waspIlluminaExitCondition" />
				</bean>
			</batch:tasklet>
		</batch:step>
	</batch:flow>


	<batch:job id="waspIlluminaHiSeq.jobFlow">
		<batch:split id="waspIlluminaHiSeq.jobFlow.split" task-executor="taskExecutor">
			<!-- this is the Illumina work flow -->
			<batch:flow parent="waspIlluminaHiSeq.mainFlow" />
			<!-- this is a concurrent flow that monitors for messages -->
			<batch:flow parent="waspIlluminaHiSeq.exitCondition" />
		</batch:split>
	</batch:job>

</beans>
