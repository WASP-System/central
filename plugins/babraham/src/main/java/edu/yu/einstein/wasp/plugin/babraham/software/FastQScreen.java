/**
 * 
 */
package edu.yu.einstein.wasp.plugin.babraham.software;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;

import edu.yu.einstein.wasp.filetype.FastqComparator;
import edu.yu.einstein.wasp.filetype.service.FastqService;
import edu.yu.einstein.wasp.grid.work.GridResult;
import edu.yu.einstein.wasp.grid.work.WorkUnit;
import edu.yu.einstein.wasp.grid.work.WorkUnit.ExecutionMode;
import edu.yu.einstein.wasp.grid.work.WorkUnit.ProcessMode;
import edu.yu.einstein.wasp.model.FileGroup;
import edu.yu.einstein.wasp.model.FileHandle;
import edu.yu.einstein.wasp.mps.illumina.IlluminaSequenceRunProcessor;
import edu.yu.einstein.wasp.software.SoftwarePackage;

/**
 * @author calder
 *
 */
public class FastQScreen extends SoftwarePackage {

	@Autowired
	private FastqService fastqService;
	
	@Autowired
	private IlluminaSequenceRunProcessor casava;

	/**
	 * 
	 */
	private static final long serialVersionUID = -2863597794926320890L;

	/**
	 * Don't use the whole sequence file to search when preforming fastq_screen; instead create a temporary dataset of size subset
	 */
	private static final long subset = 500000L;
	
	/**
	 * 
	 */
	public FastQScreen() {
		// TODO Auto-generated constructor stub
	}

	/** 
	 * {@inheritDoc}
	 */
	@Override
	public String getSoftwareVersion() {
		// TODO Auto-generated method stub
		return null;
	}

	/** 
	 * {@inheritDoc}
	 */
	@Override
	public void setSoftwareVersion(String softwareVersion) {
		// TODO Auto-generated method stub
		
	}

	public WorkUnit getFastQScreen(FileGroup fileGroup) {
		WorkUnit w = new WorkUnit();
		
		// require fastqc
		List<SoftwarePackage> software = new ArrayList<SoftwarePackage>();
		software.add(this);
		w.setSoftwareDependencies(software);
		
		// require 1GB memory
		w.setMemoryRequirements(1);
		
		// require a single thread, execution mode PROCESS
		// indicates this is a vanilla exectuion.
		w.setProcessMode(ProcessMode.SINGLE);
		w.setMode(ExecutionMode.PROCESS);
		
		// set working directory to scratch
		w.setWorkingDirectory(WorkUnit.SCRATCH_DIR_PLACEHOLDER);
		
		// we aren't actually going to retain any files, so we will set the output
		// directory to the scratch directory.  Also set "secure results" to
		// false to indicate that we don't care about the output.
		w.setResultsDirectory(WorkUnit.SCRATCH_DIR_PLACEHOLDER);
		w.setSecureResults(false);
		
		// add the files to the work unit
		// files will be represented as bash variables in the work unit and
		// are sorted using the FastqComparator.  For single samples (what we have here)
		// this ensures that they will be in groups of read segments.
		// e.g.
		// s1.R1.001
		// s1.R2.001
		// s1.R1.002
		// s1.R2.002
		List<FileHandle> files = new ArrayList<FileHandle>(fileGroup.getFileHandles());
		Collections.sort(files, new FastqComparator(fastqService));//this comparator appears to order files like: a read (R1_001.fq), followed immediately by its mate (R2_001.fq),  if it was a paired end read. This is exactly what fastq_screen requires.
		w.setRequiredFiles(files);
		
		// set the command
		w.setCommand(getCommand(fileGroup));
		
		return w;
	}
	
	/**
	 * Set the fastqscreen command.  Choose casava mode if the data was generated by the Illumina plugin.
	 * 
	 * @param fileGroup
	 * @return String
	 */
	private String getCommand(FileGroup fileGroup) {
		
		String command = "";
		int segments = fastqService.getNumberOfReadSegments(fileGroup);
		int files = fileGroup.getFileHandles().size();
		
		String[] fileList = new String[segments];
		
		for (int i = 0; i < segments; i++) {
			for (int j = 0; j < (files/segments); j++) {
				int index = ((j-1) * segments) + (i-1);
				fileList[i] += " ${" + WorkUnit.INPUT_FILE + "[" + index + "]}";
			}
		}
		
		String opts = "--quiet --subset " + subset;
		
		//HOW TO TELL IF PAIRED END SET OF READS?//we'll just use the forward reads for fastq_screen
		
		for (int i = 0; i < segments; i++) {
			int dir = i+1;
			command += "mkdir " + dir + "\n";
			// if casava, use casava mode
			if (fileGroup.getSoftwareGeneratedBy().equals(casava)) { //Assume quality values are in encoded in Illumina v1.3 format, so add the flag --illumina1_3 (otherwise assume quality values  are in Sanger format)
				//command += "fastqc --casava " + opts + " --outdir " + i + " " + fileList[i] + "\n";
				command += "fastq_screen --illumina1_3 " + opts + " --outdir " + i + " " + fileList[i] + "\n";
			} else {
				// otherwise treat like fastq
				String name = i + ".fq";
				//command += "zcat " + fileList[i] + " > " + name + " && fastqc " + opts + " --outdir " + i + " " + name;
				command += "zcat " + fileList[i] + " > " + name + " && fastq_screen " + opts + " --outdir " + i + " " + name + "\n";
			}
		}

		return command;
	}
	public String parseOutput(GridResult result) {
		return null;
	}
}
